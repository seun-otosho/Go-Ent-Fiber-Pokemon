// Code generated by ogen, DO NOT EDIT.

package ogent

import (
	"net/http"

	"github.com/go-faster/errors"

	"github.com/ogen-go/ogen/conv"
	"github.com/ogen-go/ogen/uri"
)

type DeleteBattleParams struct {
	// ID of the Battle.
	ID int
}

func unpackDeleteBattleParams(packed map[string]any) (params DeleteBattleParams) {
	params.ID = packed["id"].(int)
	return params
}

func decodeDeleteBattleParams(args [1]string, r *http.Request) (params DeleteBattleParams, _ error) {
	// Decode path: id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: id: parse")
			}
		} else {
			return params, errors.New("path: id: not specified")
		}
	}
	return params, nil
}

type DeleteCarParams struct {
	// ID of the Car.
	ID int
}

func unpackDeleteCarParams(packed map[string]any) (params DeleteCarParams) {
	params.ID = packed["id"].(int)
	return params
}

func decodeDeleteCarParams(args [1]string, r *http.Request) (params DeleteCarParams, _ error) {
	// Decode path: id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: id: parse")
			}
		} else {
			return params, errors.New("path: id: not specified")
		}
	}
	return params, nil
}

type DeleteGroupParams struct {
	// ID of the Group.
	ID int
}

func unpackDeleteGroupParams(packed map[string]any) (params DeleteGroupParams) {
	params.ID = packed["id"].(int)
	return params
}

func decodeDeleteGroupParams(args [1]string, r *http.Request) (params DeleteGroupParams, _ error) {
	// Decode path: id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: id: parse")
			}
		} else {
			return params, errors.New("path: id: not specified")
		}
	}
	return params, nil
}

type DeletePetParams struct {
	// ID of the Pet.
	ID int
}

func unpackDeletePetParams(packed map[string]any) (params DeletePetParams) {
	params.ID = packed["id"].(int)
	return params
}

func decodeDeletePetParams(args [1]string, r *http.Request) (params DeletePetParams, _ error) {
	// Decode path: id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: id: parse")
			}
		} else {
			return params, errors.New("path: id: not specified")
		}
	}
	return params, nil
}

type DeletePokemonParams struct {
	// ID of the Pokemon.
	ID int
}

func unpackDeletePokemonParams(packed map[string]any) (params DeletePokemonParams) {
	params.ID = packed["id"].(int)
	return params
}

func decodeDeletePokemonParams(args [1]string, r *http.Request) (params DeletePokemonParams, _ error) {
	// Decode path: id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: id: parse")
			}
		} else {
			return params, errors.New("path: id: not specified")
		}
	}
	return params, nil
}

type DeleteUserParams struct {
	// ID of the User.
	ID int
}

func unpackDeleteUserParams(packed map[string]any) (params DeleteUserParams) {
	params.ID = packed["id"].(int)
	return params
}

func decodeDeleteUserParams(args [1]string, r *http.Request) (params DeleteUserParams, _ error) {
	// Decode path: id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: id: parse")
			}
		} else {
			return params, errors.New("path: id: not specified")
		}
	}
	return params, nil
}

type ListBattleParams struct {
	// What page to render.
	Page OptInt
	// Item count to render per page.
	ItemsPerPage OptInt
}

func unpackListBattleParams(packed map[string]any) (params ListBattleParams) {
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	if v, ok := packed["itemsPerPage"]; ok {
		params.ItemsPerPage = v.(OptInt)
	}
	return params
}

func decodeListBattleParams(args [0]string, r *http.Request) (params ListBattleParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	// Decode query: itemsPerPage.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "itemsPerPage",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotItemsPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotItemsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ItemsPerPage.SetTo(paramsDotItemsPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: itemsPerPage: parse")
			}
		}
	}
	return params, nil
}

type ListCarParams struct {
	// What page to render.
	Page OptInt
	// Item count to render per page.
	ItemsPerPage OptInt
}

func unpackListCarParams(packed map[string]any) (params ListCarParams) {
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	if v, ok := packed["itemsPerPage"]; ok {
		params.ItemsPerPage = v.(OptInt)
	}
	return params
}

func decodeListCarParams(args [0]string, r *http.Request) (params ListCarParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	// Decode query: itemsPerPage.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "itemsPerPage",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotItemsPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotItemsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ItemsPerPage.SetTo(paramsDotItemsPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: itemsPerPage: parse")
			}
		}
	}
	return params, nil
}

type ListGroupParams struct {
	// What page to render.
	Page OptInt
	// Item count to render per page.
	ItemsPerPage OptInt
}

func unpackListGroupParams(packed map[string]any) (params ListGroupParams) {
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	if v, ok := packed["itemsPerPage"]; ok {
		params.ItemsPerPage = v.(OptInt)
	}
	return params
}

func decodeListGroupParams(args [0]string, r *http.Request) (params ListGroupParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	// Decode query: itemsPerPage.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "itemsPerPage",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotItemsPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotItemsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ItemsPerPage.SetTo(paramsDotItemsPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: itemsPerPage: parse")
			}
		}
	}
	return params, nil
}

type ListGroupUsersParams struct {
	// ID of the Group.
	ID int
	// What page to render.
	Page OptInt
	// Item count to render per page.
	ItemsPerPage OptInt
}

func unpackListGroupUsersParams(packed map[string]any) (params ListGroupUsersParams) {
	params.ID = packed["id"].(int)
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	if v, ok := packed["itemsPerPage"]; ok {
		params.ItemsPerPage = v.(OptInt)
	}
	return params
}

func decodeListGroupUsersParams(args [1]string, r *http.Request) (params ListGroupUsersParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: id: parse")
			}
		} else {
			return params, errors.New("path: id: not specified")
		}
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	// Decode query: itemsPerPage.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "itemsPerPage",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotItemsPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotItemsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ItemsPerPage.SetTo(paramsDotItemsPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: itemsPerPage: parse")
			}
		}
	}
	return params, nil
}

type ListPetParams struct {
	// What page to render.
	Page OptInt
	// Item count to render per page.
	ItemsPerPage OptInt
}

func unpackListPetParams(packed map[string]any) (params ListPetParams) {
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	if v, ok := packed["itemsPerPage"]; ok {
		params.ItemsPerPage = v.(OptInt)
	}
	return params
}

func decodeListPetParams(args [0]string, r *http.Request) (params ListPetParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	// Decode query: itemsPerPage.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "itemsPerPage",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotItemsPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotItemsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ItemsPerPage.SetTo(paramsDotItemsPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: itemsPerPage: parse")
			}
		}
	}
	return params, nil
}

type ListPokemonParams struct {
	// What page to render.
	Page OptInt
	// Item count to render per page.
	ItemsPerPage OptInt
}

func unpackListPokemonParams(packed map[string]any) (params ListPokemonParams) {
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	if v, ok := packed["itemsPerPage"]; ok {
		params.ItemsPerPage = v.(OptInt)
	}
	return params
}

func decodeListPokemonParams(args [0]string, r *http.Request) (params ListPokemonParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	// Decode query: itemsPerPage.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "itemsPerPage",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotItemsPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotItemsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ItemsPerPage.SetTo(paramsDotItemsPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: itemsPerPage: parse")
			}
		}
	}
	return params, nil
}

type ListPokemonFightsParams struct {
	// ID of the Pokemon.
	ID int
	// What page to render.
	Page OptInt
	// Item count to render per page.
	ItemsPerPage OptInt
}

func unpackListPokemonFightsParams(packed map[string]any) (params ListPokemonFightsParams) {
	params.ID = packed["id"].(int)
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	if v, ok := packed["itemsPerPage"]; ok {
		params.ItemsPerPage = v.(OptInt)
	}
	return params
}

func decodeListPokemonFightsParams(args [1]string, r *http.Request) (params ListPokemonFightsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: id: parse")
			}
		} else {
			return params, errors.New("path: id: not specified")
		}
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	// Decode query: itemsPerPage.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "itemsPerPage",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotItemsPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotItemsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ItemsPerPage.SetTo(paramsDotItemsPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: itemsPerPage: parse")
			}
		}
	}
	return params, nil
}

type ListPokemonOpponentsParams struct {
	// ID of the Pokemon.
	ID int
	// What page to render.
	Page OptInt
	// Item count to render per page.
	ItemsPerPage OptInt
}

func unpackListPokemonOpponentsParams(packed map[string]any) (params ListPokemonOpponentsParams) {
	params.ID = packed["id"].(int)
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	if v, ok := packed["itemsPerPage"]; ok {
		params.ItemsPerPage = v.(OptInt)
	}
	return params
}

func decodeListPokemonOpponentsParams(args [1]string, r *http.Request) (params ListPokemonOpponentsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: id: parse")
			}
		} else {
			return params, errors.New("path: id: not specified")
		}
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	// Decode query: itemsPerPage.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "itemsPerPage",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotItemsPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotItemsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ItemsPerPage.SetTo(paramsDotItemsPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: itemsPerPage: parse")
			}
		}
	}
	return params, nil
}

type ListUserParams struct {
	// What page to render.
	Page OptInt
	// Item count to render per page.
	ItemsPerPage OptInt
}

func unpackListUserParams(packed map[string]any) (params ListUserParams) {
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	if v, ok := packed["itemsPerPage"]; ok {
		params.ItemsPerPage = v.(OptInt)
	}
	return params
}

func decodeListUserParams(args [0]string, r *http.Request) (params ListUserParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	// Decode query: itemsPerPage.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "itemsPerPage",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotItemsPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotItemsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ItemsPerPage.SetTo(paramsDotItemsPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: itemsPerPage: parse")
			}
		}
	}
	return params, nil
}

type ListUserCarsParams struct {
	// ID of the User.
	ID int
	// What page to render.
	Page OptInt
	// Item count to render per page.
	ItemsPerPage OptInt
}

func unpackListUserCarsParams(packed map[string]any) (params ListUserCarsParams) {
	params.ID = packed["id"].(int)
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	if v, ok := packed["itemsPerPage"]; ok {
		params.ItemsPerPage = v.(OptInt)
	}
	return params
}

func decodeListUserCarsParams(args [1]string, r *http.Request) (params ListUserCarsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: id: parse")
			}
		} else {
			return params, errors.New("path: id: not specified")
		}
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	// Decode query: itemsPerPage.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "itemsPerPage",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotItemsPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotItemsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ItemsPerPage.SetTo(paramsDotItemsPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: itemsPerPage: parse")
			}
		}
	}
	return params, nil
}

type ListUserGroupsParams struct {
	// ID of the User.
	ID int
	// What page to render.
	Page OptInt
	// Item count to render per page.
	ItemsPerPage OptInt
}

func unpackListUserGroupsParams(packed map[string]any) (params ListUserGroupsParams) {
	params.ID = packed["id"].(int)
	if v, ok := packed["page"]; ok {
		params.Page = v.(OptInt)
	}
	if v, ok := packed["itemsPerPage"]; ok {
		params.ItemsPerPage = v.(OptInt)
	}
	return params
}

func decodeListUserGroupsParams(args [1]string, r *http.Request) (params ListUserGroupsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode path: id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: id: parse")
			}
		} else {
			return params, errors.New("path: id: not specified")
		}
	}
	// Decode query: page.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "page",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Page.SetTo(paramsDotPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: page: parse")
			}
		}
	}
	// Decode query: itemsPerPage.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "itemsPerPage",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotItemsPerPageVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotItemsPerPageVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ItemsPerPage.SetTo(paramsDotItemsPerPageVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: itemsPerPage: parse")
			}
		}
	}
	return params, nil
}

type ReadBattleParams struct {
	// ID of the Battle.
	ID int
}

func unpackReadBattleParams(packed map[string]any) (params ReadBattleParams) {
	params.ID = packed["id"].(int)
	return params
}

func decodeReadBattleParams(args [1]string, r *http.Request) (params ReadBattleParams, _ error) {
	// Decode path: id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: id: parse")
			}
		} else {
			return params, errors.New("path: id: not specified")
		}
	}
	return params, nil
}

type ReadBattleContenderParams struct {
	// ID of the Battle.
	ID int
}

func unpackReadBattleContenderParams(packed map[string]any) (params ReadBattleContenderParams) {
	params.ID = packed["id"].(int)
	return params
}

func decodeReadBattleContenderParams(args [1]string, r *http.Request) (params ReadBattleContenderParams, _ error) {
	// Decode path: id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: id: parse")
			}
		} else {
			return params, errors.New("path: id: not specified")
		}
	}
	return params, nil
}

type ReadBattleOponentParams struct {
	// ID of the Battle.
	ID int
}

func unpackReadBattleOponentParams(packed map[string]any) (params ReadBattleOponentParams) {
	params.ID = packed["id"].(int)
	return params
}

func decodeReadBattleOponentParams(args [1]string, r *http.Request) (params ReadBattleOponentParams, _ error) {
	// Decode path: id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: id: parse")
			}
		} else {
			return params, errors.New("path: id: not specified")
		}
	}
	return params, nil
}

type ReadCarParams struct {
	// ID of the Car.
	ID int
}

func unpackReadCarParams(packed map[string]any) (params ReadCarParams) {
	params.ID = packed["id"].(int)
	return params
}

func decodeReadCarParams(args [1]string, r *http.Request) (params ReadCarParams, _ error) {
	// Decode path: id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: id: parse")
			}
		} else {
			return params, errors.New("path: id: not specified")
		}
	}
	return params, nil
}

type ReadGroupParams struct {
	// ID of the Group.
	ID int
}

func unpackReadGroupParams(packed map[string]any) (params ReadGroupParams) {
	params.ID = packed["id"].(int)
	return params
}

func decodeReadGroupParams(args [1]string, r *http.Request) (params ReadGroupParams, _ error) {
	// Decode path: id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: id: parse")
			}
		} else {
			return params, errors.New("path: id: not specified")
		}
	}
	return params, nil
}

type ReadPetParams struct {
	// ID of the Pet.
	ID int
}

func unpackReadPetParams(packed map[string]any) (params ReadPetParams) {
	params.ID = packed["id"].(int)
	return params
}

func decodeReadPetParams(args [1]string, r *http.Request) (params ReadPetParams, _ error) {
	// Decode path: id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: id: parse")
			}
		} else {
			return params, errors.New("path: id: not specified")
		}
	}
	return params, nil
}

type ReadPokemonParams struct {
	// ID of the Pokemon.
	ID int
}

func unpackReadPokemonParams(packed map[string]any) (params ReadPokemonParams) {
	params.ID = packed["id"].(int)
	return params
}

func decodeReadPokemonParams(args [1]string, r *http.Request) (params ReadPokemonParams, _ error) {
	// Decode path: id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: id: parse")
			}
		} else {
			return params, errors.New("path: id: not specified")
		}
	}
	return params, nil
}

type ReadUserParams struct {
	// ID of the User.
	ID int
}

func unpackReadUserParams(packed map[string]any) (params ReadUserParams) {
	params.ID = packed["id"].(int)
	return params
}

func decodeReadUserParams(args [1]string, r *http.Request) (params ReadUserParams, _ error) {
	// Decode path: id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: id: parse")
			}
		} else {
			return params, errors.New("path: id: not specified")
		}
	}
	return params, nil
}

type UpdateBattleParams struct {
	// ID of the Battle.
	ID int
}

func unpackUpdateBattleParams(packed map[string]any) (params UpdateBattleParams) {
	params.ID = packed["id"].(int)
	return params
}

func decodeUpdateBattleParams(args [1]string, r *http.Request) (params UpdateBattleParams, _ error) {
	// Decode path: id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: id: parse")
			}
		} else {
			return params, errors.New("path: id: not specified")
		}
	}
	return params, nil
}

type UpdateCarParams struct {
	// ID of the Car.
	ID int
}

func unpackUpdateCarParams(packed map[string]any) (params UpdateCarParams) {
	params.ID = packed["id"].(int)
	return params
}

func decodeUpdateCarParams(args [1]string, r *http.Request) (params UpdateCarParams, _ error) {
	// Decode path: id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: id: parse")
			}
		} else {
			return params, errors.New("path: id: not specified")
		}
	}
	return params, nil
}

type UpdateGroupParams struct {
	// ID of the Group.
	ID int
}

func unpackUpdateGroupParams(packed map[string]any) (params UpdateGroupParams) {
	params.ID = packed["id"].(int)
	return params
}

func decodeUpdateGroupParams(args [1]string, r *http.Request) (params UpdateGroupParams, _ error) {
	// Decode path: id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: id: parse")
			}
		} else {
			return params, errors.New("path: id: not specified")
		}
	}
	return params, nil
}

type UpdatePetParams struct {
	// ID of the Pet.
	ID int
}

func unpackUpdatePetParams(packed map[string]any) (params UpdatePetParams) {
	params.ID = packed["id"].(int)
	return params
}

func decodeUpdatePetParams(args [1]string, r *http.Request) (params UpdatePetParams, _ error) {
	// Decode path: id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: id: parse")
			}
		} else {
			return params, errors.New("path: id: not specified")
		}
	}
	return params, nil
}

type UpdatePokemonParams struct {
	// ID of the Pokemon.
	ID int
}

func unpackUpdatePokemonParams(packed map[string]any) (params UpdatePokemonParams) {
	params.ID = packed["id"].(int)
	return params
}

func decodeUpdatePokemonParams(args [1]string, r *http.Request) (params UpdatePokemonParams, _ error) {
	// Decode path: id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: id: parse")
			}
		} else {
			return params, errors.New("path: id: not specified")
		}
	}
	return params, nil
}

type UpdateUserParams struct {
	// ID of the User.
	ID int
}

func unpackUpdateUserParams(packed map[string]any) (params UpdateUserParams) {
	params.ID = packed["id"].(int)
	return params
}

func decodeUpdateUserParams(args [1]string, r *http.Request) (params UpdateUserParams, _ error) {
	// Decode path: id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "path: id: parse")
			}
		} else {
			return params, errors.New("path: id: not specified")
		}
	}
	return params, nil
}
